import { GitHubClient } from './github-client';
import { IssueQueue } from './issue-queue';
import { IssuePoller } from './poller';
import { ClaudeCodeProcessor } from './claude-code-processor';
import { DispatcherConfig, GitHubIssue } from './types';
import { logger } from './logger';

export class ClaudeCodeDispatcher {
  private githubClient: GitHubClient;
  private issueQueue: IssueQueue;
  private poller: IssuePoller;
  private processor: ClaudeCodeProcessor;
  private isRunning = false;
  private processingLoop: NodeJS.Timeout | null = null;

  constructor(private config: DispatcherConfig, workingDirectory?: string) {
    this.githubClient = new GitHubClient();
    this.issueQueue = new IssueQueue();
    this.poller = new IssuePoller(this.githubClient, this.issueQueue, config);
    this.processor = new ClaudeCodeProcessor(workingDirectory, config.allowedTools, config.disallowedTools);
  }

  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Dispatcher is already running');
      return;
    }

    try {
      logger.info('Starting Claude Code Dispatcher...');
      
      await this.validatePrerequisites();
      
      this.isRunning = true;
      
      await this.poller.start();
      this.startProcessingLoop();
      
      logger.info('Claude Code Dispatcher started successfully');
      logger.info('Press Ctrl+C to stop the dispatcher');
      
      this.keepAlive();
      
    } catch (error) {
      logger.error('Failed to start dispatcher:', error);
      await this.stop();
      throw error;
    }
  }

  async stop(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    logger.info('Stopping Claude Code Dispatcher...');
    
    this.isRunning = false;
    
    this.poller.stop();
    
    if (this.processingLoop) {
      clearTimeout(this.processingLoop);
      this.processingLoop = null;
    }
    
    this.issueQueue.setProcessing(false);
    
    logger.info('Claude Code Dispatcher stopped');
  }

  private async validatePrerequisites(): Promise<void> {
    try {
      const { execSync } = await import('child_process');
      
      logger.info('Validating prerequisites...');
      
      execSync('gh auth status', { stdio: 'pipe' });
      
      execSync(`gh repo view ${this.config.owner}/${this.config.repo}`, { stdio: 'pipe' });
      
      execSync('claude --version', { stdio: 'pipe' });
      
      logger.info('Prerequisites validation passed');
    } catch (error) {
      logger.error('Prerequisites validation failed:', error);
      throw new Error('Prerequisites validation failed. Please ensure GitHub CLI and Claude CLI are installed and authenticated.');
    }
  }

  private startProcessingLoop(): void {
    const processNext = async () => {
      if (!this.isRunning) {
        return;
      }

      try {
        if (!this.issueQueue.isEmpty() && !this.issueQueue.isProcessing()) {
          const issue = this.issueQueue.dequeue();
          
          if (issue) {
            await this.processIssue(issue);
          }
        }
      } catch (error) {
        logger.error('Error in processing loop:', error);
      }
      
      if (this.isRunning) {
        this.processingLoop = setTimeout(processNext, 5000);
      }
    };

    processNext();
  }

  private async processIssue(issue: GitHubIssue): Promise<void> {
    this.issueQueue.setProcessing(true);
    
    try {
      logger.info(`Starting to process issue #${issue.number}: ${issue.title}`);
      
      const result = await this.processor.processIssue(issue, this.config.baseBranch);
      
      if (result.success && result.branchName) {
        logger.info(`Successfully created pull request for issue #${issue.number}`);
      } else {
        logger.error(`Failed to process issue #${issue.number}: ${result.error}`);
        this.githubClient.markIssueAsProcessed(issue.id);
      }
      
    } catch (error) {
      logger.error(`Unexpected error processing issue #${issue.number}:`, error);
      this.githubClient.markIssueAsProcessed(issue.id);
    } finally {
      this.issueQueue.setProcessing(false);
    }
  }

private createPullRequestBody(issue: GitHubIssue, branchName: string): string {
    let body = '## ðŸ“‹ Issue Summary\n\n';
    body += `Fixes #${issue.number}\n\n`;
    body += `**Original Issue:** ${issue.title}\n\n`;
    
    if (issue.body) {
      body += `**Description:**\n${issue.body}\n\n`;
    }
    
    body += '## ðŸ”§ Changes Made\n\n';
    body += 'This pull request was automatically generated by Claude Code Dispatcher to address the requirements specified in the linked issue.\n\n';
    
    body += '## ðŸ§ª Testing\n\n';
    body += '- [ ] Code compiles without errors\n';
    body += '- [ ] All existing tests pass\n';
    body += '- [ ] New functionality works as expected\n';
    body += '- [ ] Code follows project conventions\n\n';
    
    body += '## ðŸ“š Additional Notes\n\n';
    body += `- **Branch:** \`${branchName}\`\n`;
    body += `- **Base Branch:** \`${this.config.baseBranch}\`\n`;
    body += `- **Issue URL:** ${issue.html_url}\n\n`;
    
    body += 'ðŸ¤– This pull request was automatically generated by Claude Code Dispatcher.\n';
    body += 'Please review the changes carefully before merging.';
    
    return body;
  }

  private keepAlive(): void {
    const keepAliveInterval = setInterval(() => {
      if (!this.isRunning) {
        clearInterval(keepAliveInterval);
        return;
      }
      
      const status = this.getStatus();
      logger.info(`Status - Queue: ${status.queueSize}, Processing: ${status.processing ? 'Yes' : 'No'}, Polling: ${status.polling ? 'Yes' : 'No'}`);
    }, 30000);
  }

  getStatus(): {
    polling: boolean;
    processing: boolean;
    queueSize: number;
    nextIssue?: GitHubIssue;
  } {
    const pollerStatus = this.poller.getStatus();
    const queueStatus = this.issueQueue.getStatus();
    
    return {
      polling: pollerStatus.running,
      processing: queueStatus.processing,
      queueSize: queueStatus.queueSize,
      nextIssue: queueStatus.nextIssue
    };
  }
}